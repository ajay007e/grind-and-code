# ðŸ§© 3539: Find Sum of Array Product of Magical Sequences

- **Difficulty**: `Hard`
- **Tags / Topics**: `Array`, `Math`, `Dynamic Programming`, `Bit Manipulation`, `Combinatorics`, `Bitmask`
- **Link**: [Leetcode](https://leetcode.com/problems/find-sum-of-array-product-of-magical-sequences/)

---

## ðŸ“œ Description

<p>You are given two integers, <code>m</code> and <code>k</code>, and an integer array <code>nums</code>.</p>
A sequence of integers <code>seq</code> is called <strong>magical</strong> if:

<ul>
	<li><code>seq</code> has a size of <code>m</code>.</li>
	<li><code>0 &lt;= seq[i] &lt; nums.length</code></li>
	<li>The <strong>binary representation</strong> of <code>2<sup>seq[0]</sup> + 2<sup>seq[1]</sup> + ... + 2<sup>seq[m - 1]</sup></code> has <code>k</code> <strong>set bits</strong>.</li>
</ul>

<p>The <strong>array product</strong> of this sequence is defined as <code>prod(seq) = (nums[seq[0]] * nums[seq[1]] * ... * nums[seq[m - 1]])</code>.</p>

<p>Return the <strong>sum</strong> of the <strong>array products</strong> for all valid <strong>magical</strong> sequences.</p>

<p>Since the answer may be large, return it <strong>modulo</strong> <code>10<sup>9</sup> + 7</code>.</p>

<p>A <strong>set bit</strong> refers to a bit in the binary representation of a number that has a value of 1.</p>




## ðŸ§ª Examples



## ðŸ“Œ Constraints"
<ul>
	<li><code>1 &lt;= k &lt;= m &lt;= 30</code></li>
	<li><code>1 &lt;= nums.length &lt;= 50</code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>8</sup></code></li>
</ul>



---
<!--- code section starts -->
## ðŸ§  Code



<details>
<summary>Click to read Python code</summary>

```python
class Solution:
    def magicalSum(self, m: int, k: int, nums: List[int]) -> int:
        MOD = 10**9 + 7

        @cache
        def dp(mask, m, k, i):
            if m == 0 and mask.bit_count() == k:
                return 1
            if m == 0 or i == len(nums):
                return 0

            total = 0
            total += (dp(mask >> 1, m, k - (mask & 1), i + 1)) % MOD

            for freq in range(1, m + 1):
                new_mask = mask + freq
                next = (dp(new_mask >> 1, m - freq, k - (new_mask & 1), i + 1)) % MOD
                total += (pow(nums[i], freq, MOD) * next * comb(m, freq)) % MOD
            return total

        return dp(0, m, k, 0) % MOD

```

</details>
    

<!--- code section ends -->
