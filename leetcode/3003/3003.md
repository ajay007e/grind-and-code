# ðŸ§© 3003: Maximize the Number of Partitions After Operations

- **Difficulty**: `Hard`
- **Tags / Topics**: `String`, `Dynamic Programming`, `Bit Manipulation`, `Bitmask`
- **Link**: [Leetcode](https://leetcode.com/problems/maximize-the-number-of-partitions-after-operations/)

---

## ðŸ“œ Description

<p>You are given a string <code>s</code> and an integer <code>k</code>.</p>

<p>First, you are allowed to change <strong>at most</strong> <strong>one</strong> index in <code>s</code> to another lowercase English letter.</p>

<p>After that, do the following partitioning operation until <code>s</code> is <strong>empty</strong>:</p>

<ul>
	<li>Choose the <strong>longest</strong> <strong>prefix</strong> of <code>s</code> containing at most <code>k</code> <strong>distinct</strong> characters.</li>
	<li><strong>Delete</strong> the prefix from <code>s</code> and increase the number of partitions by one. The remaining characters (if any) in <code>s</code> maintain their initial order.</li>
</ul>

<p>Return an integer denoting the <strong>maximum</strong> number of resulting partitions after the operations by optimally choosing at most one index to change.</p>




## ðŸ§ª Examples



## ðŸ“Œ Constraints"
<ul>
	<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>
	<li><code>s</code> consists only of lowercase English letters.</li>
	<li><code>1 &lt;= k &lt;= 26</code></li>
</ul>



---
<!--- code section starts -->
## ðŸ§  Code



<details>
<summary>Click to read Python code</summary>

```python
class Solution:
    def maxPartitionsAfterOperations(self, s: str, k: int) -> int:
        @cache
        def dp(mask, change, i):
            if i == len(s):
                return 1
            best = 0
            curr = ord(s[i]) - ord("a")
            nmask = mask | (1 << curr)
            if nmask.bit_count() <= k:
                best = max(best, dp(nmask, change, i + 1))
            else:
                best = max(best, dp(1 << curr, change, i + 1) + 1)

            if not change:
                for j in range(26):
                    if j == curr:
                        continue
                    nmask = mask | (1 << j)
                    if nmask.bit_count() <= k:
                        best = max(best, dp(nmask, True, i + 1))
                    else:
                        best = max(best, dp(1 << j, True, i + 1) + 1)

            return best

        return dp(0, False, 0)

```

</details>
    

<!--- code section ends -->
