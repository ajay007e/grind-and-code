# ðŸ§© 3321: Find X-Sum of All K-Long Subarrays II

- **Difficulty**: `Hard`
- **Tags / Topics**: `Array`, `Hash Table`, `Sliding Window`, `Heap (Priority Queue)`
- **Link**: [Leetcode](https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-ii/)

---

## ðŸ“œ Description

<p>You are given an array <code>nums</code> of <code>n</code> integers and two integers <code>k</code> and <code>x</code>.</p>

<p>The <strong>x-sum</strong> of an array is calculated by the following procedure:</p>

<ul>
	<li>Count the occurrences of all elements in the array.</li>
	<li>Keep only the occurrences of the top <code>x</code> most frequent elements. If two elements have the same number of occurrences, the element with the <strong>bigger</strong> value is considered more frequent.</li>
	<li>Calculate the sum of the resulting array.</li>
</ul>

<p><strong>Note</strong> that if an array has less than <code>x</code> distinct elements, its <strong>x-sum</strong> is the sum of the array.</p>

<p>Return an integer array <code>answer</code> of length <code>n - k + 1</code> where <code>answer[i]</code> is the <strong>x-sum</strong> of the <span data-keyword="subarray-nonempty">subarray</span> <code>nums[i..i + k - 1]</code>.</p>




## ðŸ§ª Examples



## ðŸ“Œ Constraints"
<ul>
	<li><code>nums.length == n</code></li>
	<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>
	<li><code>1 &lt;= x &lt;= k &lt;= nums.length</code></li>
</ul>



---
<!--- code section starts -->
## ðŸ§  Code



<details>
<summary>Click to read Python code</summary>

```python
class Solution:
    def findXSum(self, nums: List[int], k: int, x: int) -> List[int]:
        n, res = len(nums), []
        fm = defaultdict(int)
        top, low = SortedList(), SortedList()
        curr = 0

        def change(num, count):
            nonlocal curr

            prev = (fm[num], num)
            if fm[num]:
                if prev in low:
                    low.discard(prev)
                else:
                    top.discard(prev)
                    curr -= fm[num] * num
            fm[num] += count

            if fm[num]:
                low.add((fm[num], num))

            while low and len(top) < x:
                freq, key = low.pop(-1)
                curr += freq * key
                top.add((freq, key))

            while low and low[-1] > top[0]:
                freq, key = low.pop(-1)
                xfreq, xkey = top.pop(0)
                curr = curr - xfreq * xkey + freq * key
                low.add((xfreq, xkey))
                top.add((freq, key))

        for i in range(n):
            change(nums[i], 1)
            if i >= k:
                change(nums[i - k], -1)
            if i >= k - 1:
                res.append(curr)
        return res

```

</details>
    

<!--- code section ends -->
