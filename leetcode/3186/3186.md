# ðŸ§© 3186: Maximum Total Damage With Spell Casting

- **Difficulty**: `Medium`
- **Tags / Topics**: `Array`, `Hash Table`, `Two Pointers`, `Binary Search`, `Dynamic Programming`, `Sorting`, `Counting`
- **Link**: [Leetcode](https://leetcode.com/problems/maximum-total-damage-with-spell-casting/)

---

## ðŸ“œ Description

<p>A magician has various spells.</p>

<p>You are given an array <code>power</code>, where each element represents the damage of a spell. Multiple spells can have the same damage value.</p>

<p>It is a known fact that if a magician decides to cast a spell with a damage of <code>power[i]</code>, they <strong>cannot</strong> cast any spell with a damage of <code>power[i] - 2</code>, <code>power[i] - 1</code>, <code>power[i] + 1</code>, or <code>power[i] + 2</code>.</p>

<p>Each spell can be cast <strong>only once</strong>.</p>

<p>Return the <strong>maximum</strong> possible <em>total damage</em> that a magician can cast.</p>




## ðŸ§ª Examples



## ðŸ“Œ Constraints"
<ul>
	<li><code>1 &lt;= power.length &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= power[i] &lt;= 10<sup>9</sup></code></li>
</ul>



---
<!--- code section starts -->
## ðŸ§  Code



<details>
<summary>Click to read Python code</summary>

```python
class Solution:
    def maximumTotalDamage(self, power: List[int]) -> int:
        fm = defaultdict(int)
        for x in power:
            fm[x] += 1
        unique = sorted(list(fm.keys()))
        n, k, mx = len(unique), 0, 0
        dp = [0] * n

        for i in range(n):
            while k < i and unique[k] < unique[i] - 2:
                mx = max(mx, dp[k])
                k += 1
            val = unique[i]
            dp[i] = mx + val * fm[val]

        return max(dp)

```

</details>
    

<!--- code section ends -->
