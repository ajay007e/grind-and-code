# ðŸ§© 3459: Length of Longest V-Shaped Diagonal Segment

- **Difficulty**: `Hard`
- **Tags / Topics**: `Array`, `Dynamic Programming`, `Memoization`, `Matrix`
- **Link**: [Leetcode](https://leetcode.com/problems/length-of-longest-v-shaped-diagonal-segment/)

---

## ðŸ“œ Description

<p>You are given a 2D integer matrix <code>grid</code> of size <code>n x m</code>, where each element is either <code>0</code>, <code>1</code>, or <code>2</code>.</p>

<p>A <strong>V-shaped diagonal segment</strong> is defined as:</p>

<ul>
	<li>The segment starts with <code>1</code>.</li>
	<li>The subsequent elements follow this infinite sequence: <code>2, 0, 2, 0, ...</code>.</li>
	<li>The segment:
	<ul>
		<li>Starts <strong>along</strong> a diagonal direction (top-left to bottom-right, bottom-right to top-left, top-right to bottom-left, or bottom-left to top-right).</li>
		<li>Continues the<strong> sequence</strong> in the same diagonal direction.</li>
		<li>Makes<strong> at most one clockwise 90-degree</strong><strong> turn</strong> to another diagonal direction while <strong>maintaining</strong> the sequence.</li>
	</ul>
	</li>
</ul>

<p><img alt="" src="https://assets.leetcode.com/uploads/2025/01/11/length_of_longest3.jpg" style="width: 481px; height: 202px;" /></p>

<p>Return the <strong>length</strong> of the <strong>longest</strong> <strong>V-shaped diagonal segment</strong>. If no valid segment <em>exists</em>, return 0.</p>




## ðŸ§ª Examples



## ðŸ“Œ Constraints"
<ul>
	<li><code>n == grid.length</code></li>
	<li><code>m == grid[i].length</code></li>
	<li><code>1 &lt;= n, m &lt;= 500</code></li>
	<li><code>grid[i][j]</code> is either <code>0</code>, <code>1</code> or <code>2</code>.</li>
</ul>



---
<!--- code section starts -->
## ðŸ§  Code



<details>
<summary>Click to read Python code</summary>

```python
class Solution:
    def lenOfVDiagonal(self, grid: List[List[int]]) -> int:
        n = len(grid)
        m = len(grid[0])

        dirs = [(-1, -1), (-1, 1), (1, 1), (1, -1)]

        @cache
        def dfs(i, j, target, turn, dir):
            if i < 0 or i >= n or j < 0 or j >= m or grid[i][j] != target:
                return 0

            target = 0 if target == 2 else 2
            ni = i + dirs[dir][0]
            nj = j + dirs[dir][1]
            total = 0

            if turn:
                total = max(total, dfs(ni, nj, target, True, dir) + 1)
            else:
                total = max(total, dfs(ni, nj, target, False, dir) + 1)
                new_dir = (dir + 1) % 4
                ni = i + dirs[new_dir][0]
                nj = j + dirs[new_dir][1]

                total = max(total, dfs(ni, nj, target, True, new_dir) + 1)

            return total

        res = 0
        for i in range(n):
            for j in range(m):
                if grid[i][j] == 1:
                    for d in range(4):
                        res = max(
                            res, dfs(i + dirs[d][0], j + dirs[d][1], 2, False, d) + 1
                        )
        return res

```

</details>
    

<!--- code section ends -->
