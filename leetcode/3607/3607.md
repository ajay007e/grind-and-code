# ðŸ§© 3607: Power Grid Maintenance

- **Difficulty**: `Medium`
- **Tags / Topics**: `Array`, `Hash Table`, `Depth-First Search`, `Breadth-First Search`, `Union Find`, `Graph`, `Heap (Priority Queue)`, `Ordered Set`
- **Link**: [Leetcode](https://leetcode.com/problems/power-grid-maintenance/)

---

## ðŸ“œ Description

<p data-end="401" data-start="120">You are given an integer <code data-end="194" data-start="191">c</code> representing <code data-end="211" data-start="208">c</code> power stations, each with a unique identifier <code>id</code> from 1 to <code>c</code> (1â€‘based indexing).</p>

<p data-end="401" data-start="120">These stations are interconnected via <code data-end="295" data-start="292">n</code> <strong>bidirectional</strong> cables, represented by a 2D array <code data-end="357" data-start="344">connections</code>, where each element <code data-end="430" data-start="405">connections[i] = [u<sub>i</sub>, v<sub>i</sub>]</code> indicates a connection between station <code>u<sub>i</sub></code> and station <code>v<sub>i</sub></code>. Stations that are directly or indirectly connected form a <strong>power grid</strong>.</p>

<p data-end="626" data-start="586">Initially, <strong>all</strong> stations are online (operational).</p>

<p data-end="720" data-start="628">You are also given a 2D array <code data-end="667" data-start="658">queries</code>, where each query is one of the following <em>two</em> types:</p>

<ul data-end="995" data-start="722">
	<li data-end="921" data-start="722">
	<p data-end="921" data-start="724"><code data-end="732" data-start="724">[1, x]</code>: A maintenance check is requested for station <code data-end="782" data-start="779">x</code>. If station <code>x</code> is online, it resolves the check by itself. If station <code>x</code> is offline, the check is resolved by the operational station with the smallest <code>id</code> in the same <strong>power grid</strong> as <code>x</code>. If <strong>no</strong> <strong>operational</strong> station <em>exists</em> in that grid, return -1.</p>
	</li>
	<li data-end="995" data-start="923">
	<p data-end="995" data-start="925"><code data-end="933" data-start="925">[2, x]</code>: Station <code data-end="946" data-start="943">x</code> goes offline (i.e., it becomes non-operational).</p>
	</li>
</ul>

<p data-end="1106" data-start="997">Return an array of integers representing the results of each query of type <code data-end="1080" data-start="1072">[1, x]</code> in the <strong>order</strong> they appear.</p>

<p data-end="1106" data-start="997"><strong>Note:</strong> The power grid preserves its structure; an offline (nonâ€‘operational) node remains part of its grid and taking it offline does not alter connectivity.</p>




## ðŸ§ª Examples



## ðŸ“Œ Constraints"
<ul>
	<li data-end="155" data-start="139"><code>1 &lt;= c &lt;= 10<sup>5</sup></code></li>
	<li data-end="213" data-start="158"><code>0 &lt;= n == connections.length &lt;= min(10<sup>5</sup>, c * (c - 1) / 2)</code></li>
	<li data-end="244" data-start="216"><code>connections[i].length == 2</code></li>
	<li data-end="295" data-start="247"><code>1 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt;= c</code></li>
	<li data-end="338" data-start="298"><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li data-end="374" data-start="341"><code>1 &lt;= queries.length &lt;= 2 * 10<sup>5</sup></code></li>
	<li data-end="401" data-start="377"><code>queries[i].length == 2</code></li>
	<li data-end="436" data-start="404"><code>queries[i][0]</code> is either 1 or 2.</li>
	<li data-end="462" data-start="439"><code>1 &lt;= queries[i][1] &lt;= c</code></li>
</ul>



---
<!--- code section starts -->
## ðŸ§  Code



<details>
<summary>Click to read Python code</summary>

```python
class Solution:
    def processQueries(
        self, c: int, connections: List[List[int]], queries: List[List[int]]
    ) -> List[int]:
        adj = defaultdict(list)
        for a, b in connections:
            adj[a].append(b)
            adj[b].append(a)

        def dfs(id, pg_id):
            seen.add(id)
            pg.append(id)
            id_pg[id] = pg_id
            for nei in adj[id]:
                if nei not in seen:
                    dfs(nei, pg_id)

        seen = set()
        id_pg = {}
        pgs = {}
        pgs_s = {}
        pg_id = 1

        for id in range(1, c + 1):
            if id in seen:
                continue
            pg = []
            dfs(id, pg_id)
            pgs_s[pg_id] = set(pg)
            heapq.heapify(pg)
            pgs[pg_id] = pg
            pg_id += 1

        res = []
        for t, id in queries:
            pgi = id_pg[id]
            pg_set = pgs_s[pgi]
            pg_heap = pgs[pgi]

            if t == 1:
                if id in pg_set:
                    res.append(id)
                else:
                    while pg_heap and pg_heap[0] not in pg_set:
                        heapq.heappop(pg_heap)
                    if pg_heap:
                        res.append(pg_heap[0])
                    else:
                        res.append(-1)
            else:
                if id in pg_set:
                    pg_set.remove(id)

        return res

```

</details>
    

<!--- code section ends -->
